---
phase: 09-gamification
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/lib/gamification-actions.ts
  - src/lib/post-actions.ts
  - src/lib/comment-actions.ts
  - src/lib/like-actions.ts
  - src/lib/progress-actions.ts
autonomous: true

must_haves:
  truths:
    - "User earns points when creating posts"
    - "User earns points when commenting"
    - "User earns points when their content receives likes"
    - "User earns points when completing lessons"
    - "User level updates when crossing threshold"
  artifacts:
    - path: "src/lib/gamification-actions.ts"
      provides: "awardPoints helper with level-up detection"
      exports: ["awardPoints"]
    - path: "src/lib/post-actions.ts"
      provides: "Point award on post creation"
      contains: "awardPoints"
    - path: "src/lib/comment-actions.ts"
      provides: "Point award on comment creation"
      contains: "awardPoints"
    - path: "src/lib/like-actions.ts"
      provides: "Point award to content author on like"
      contains: "awardPoints"
    - path: "src/lib/progress-actions.ts"
      provides: "Point award on lesson completion"
      contains: "awardPoints"
  key_links:
    - from: "src/lib/post-actions.ts"
      to: "src/lib/gamification-actions.ts"
      via: "awardPoints import and call"
      pattern: "awardPoints.*POST_CREATED"
    - from: "src/lib/like-actions.ts"
      to: "src/lib/gamification-actions.ts"
      via: "awardPoints to post/comment author"
      pattern: "awardPoints.*LIKE_RECEIVED"
---

<objective>
Integrate point awards into existing server actions: posts, comments, likes, and lesson completion.

Purpose: Users silently earn points for engagement actions, with level updated when thresholds are crossed.
Output: Modified server actions that award points atomically, awardPoints helper that handles level-up logic.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-gamification/09-CONTEXT.md
@.planning/phases/09-gamification/09-RESEARCH.md
@.planning/phases/09-gamification/09-01-SUMMARY.md
@src/lib/post-actions.ts
@src/lib/comment-actions.ts
@src/lib/like-actions.ts
@src/lib/progress-actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gamification-actions.ts with awardPoints helper</name>
  <files>src/lib/gamification-actions.ts</files>
  <action>
Create gamification-actions.ts with awardPoints helper that:
1. Uses Prisma atomic increment for points (avoid race conditions)
2. Logs PointsEvent for time-based leaderboards
3. Checks if user crossed level threshold and updates level
4. Returns `{ levelUp: boolean, newLevel?: number }` for toast trigger

```typescript
'use server';

import db from '@/lib/db';
import { POINTS, calculateLevel } from '@/lib/gamification-config';

export type PointAction = keyof typeof POINTS;

export async function awardPoints(
  userId: string,
  action: PointAction
): Promise<{ levelUp: boolean; newLevel?: number }> {
  const amount = POINTS[action];

  // Use transaction to ensure atomicity
  const result = await db.$transaction(async (tx) => {
    // 1. Log the points event (for time-based leaderboards)
    await tx.pointsEvent.create({
      data: {
        userId,
        amount,
        action,
      },
    });

    // 2. Atomic increment points and get updated user
    const user = await tx.user.update({
      where: { id: userId },
      data: { points: { increment: amount } },
      select: { points: true, level: true },
    });

    // 3. Check if user crossed level threshold
    const newLevel = calculateLevel(user.points);
    if (newLevel > user.level) {
      await tx.user.update({
        where: { id: userId },
        data: { level: newLevel },
      });
      return { levelUp: true, newLevel };
    }

    return { levelUp: false };
  });

  return result;
}
```

Note: Per CONTEXT.md, points are NOT deducted on unlike/delete. This is intentional - points are permanently awarded.
  </action>
  <verify>
TypeScript compiles without errors.
Import works from other files.
  </verify>
  <done>gamification-actions.ts exports awardPoints with atomic increment, event logging, and level-up detection</done>
</task>

<task type="auto">
  <name>Task 2: Integrate point awards into existing server actions</name>
  <files>src/lib/post-actions.ts, src/lib/comment-actions.ts, src/lib/like-actions.ts, src/lib/progress-actions.ts</files>
  <action>
Modify each existing server action to call awardPoints after successful creation:

**post-actions.ts - createPost:**
After successful `db.post.create`, add:
```typescript
import { awardPoints } from '@/lib/gamification-actions';
// ... after db.post.create succeeds:
await awardPoints(session.user.id, 'POST_CREATED');
```

**comment-actions.ts - createComment:**
After successful `db.comment.create`, add:
```typescript
import { awardPoints } from '@/lib/gamification-actions';
// ... after db.comment.create succeeds:
await awardPoints(session.user.id, 'COMMENT_CREATED');
```

**like-actions.ts - togglePostLike:**
When creating a new like (not unliking), award points to the POST AUTHOR (not the liker):
```typescript
import { awardPoints } from '@/lib/gamification-actions';
// ... inside the !existingLike branch:
// Get post author first
const post = await db.post.findUnique({
  where: { id: postId },
  select: { authorId: true },
});
// Create like
await db.postLike.create({ data: { userId, postId } });
// Award points to post author (not the liker!)
if (post) {
  await awardPoints(post.authorId, 'LIKE_RECEIVED');
}
```

**like-actions.ts - toggleCommentLike:**
Similar pattern - award points to COMMENT AUTHOR:
```typescript
// ... inside the !existingLike branch:
// Get comment author
const commentWithAuthor = await db.comment.findUnique({
  where: { id: commentId },
  select: { authorId: true, postId: true },
});
// Create like
await db.commentLike.create({ data: { userId, commentId } });
// Award points to comment author
if (commentWithAuthor) {
  await awardPoints(commentWithAuthor.authorId, 'LIKE_RECEIVED');
}
```

**progress-actions.ts - toggleLessonComplete:**
When marking lesson complete (not uncompleting), award points:
```typescript
import { awardPoints } from '@/lib/gamification-actions';
// ... inside the !existingProgress branch (when completing):
await db.lessonProgress.create({ data: { userId, lessonId } });
await awardPoints(userId, 'LESSON_COMPLETED');
```

IMPORTANT: Per CONTEXT.md - no instant toast when earning points. Points update silently.
The awardPoints return value ({ levelUp, newLevel }) is NOT used in these actions.
Level-up toast will be handled differently (triggered on page load when level changed).
  </action>
  <verify>
All four action files import awardPoints successfully.
TypeScript compiles without errors: `npm run build`.
Create a test post and verify PointsEvent is logged (check via Prisma Studio).
  </verify>
  <done>All four server actions award points: post creation (5pts), comment (2pts), like received (1pt), lesson complete (10pts)</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. Create a post -> check PointsEvent table has new entry with action="POST_CREATED"
3. Create a comment -> check PointsEvent has action="COMMENT_CREATED"
4. Like a post -> check PointsEvent shows LIKE_RECEIVED for the post author (not liker)
5. Complete a lesson -> check PointsEvent has action="LESSON_COMPLETED"
6. User.points field increments correctly
</verification>

<success_criteria>
- gamification-actions.ts exists with awardPoints function
- createPost awards 5 points to author
- createComment awards 2 points to author
- togglePostLike awards 1 point to POST AUTHOR when liked
- toggleCommentLike awards 1 point to COMMENT AUTHOR when liked
- toggleLessonComplete awards 10 points when completing (not uncompleting)
- PointsEvent records are created for each award (for time-based leaderboards)
- Level updates when user crosses threshold
</success_criteria>

<output>
After completion, create `.planning/phases/09-gamification/09-02-SUMMARY.md`
</output>
