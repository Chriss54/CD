---
phase: 10-admin-moderation
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/lib/admin-actions.ts
  - src/app/(main)/admin/posts/page.tsx
  - src/app/(main)/admin/comments/page.tsx
  - src/components/admin/post-table.tsx
  - src/components/admin/comment-table.tsx
  - src/components/admin/edit-post-dialog.tsx
  - src/components/admin/edit-comment-dialog.tsx
autonomous: true

must_haves:
  truths:
    - "Owner/Admin can view list of all posts in admin panel"
    - "Owner/Admin/Moderator can edit any post"
    - "Owner/Admin/Moderator can delete any post"
    - "Owner/Admin can view list of all comments in admin panel"
    - "Owner/Admin/Moderator can edit any comment"
    - "Owner/Admin/Moderator can delete any comment"
    - "All moderation actions are logged in audit log"
  artifacts:
    - path: "src/lib/admin-actions.ts"
      provides: "Content moderation server actions"
      exports: ["editPostAsAdmin", "deletePostAsAdmin", "editCommentAsAdmin", "deleteCommentAsAdmin"]
    - path: "src/app/(main)/admin/posts/page.tsx"
      provides: "Post moderation list page"
    - path: "src/app/(main)/admin/comments/page.tsx"
      provides: "Comment moderation list page"
    - path: "src/components/admin/edit-post-dialog.tsx"
      provides: "Post edit dialog for moderators"
    - path: "src/components/admin/edit-comment-dialog.tsx"
      provides: "Comment edit dialog for moderators"
  key_links:
    - from: "src/lib/admin-actions.ts"
      to: "src/lib/audit-actions.ts"
      via: "logAuditEvent call"
      pattern: "logAuditEvent"
    - from: "src/lib/admin-actions.ts"
      to: "src/lib/permissions.ts"
      via: "canModerateContent check"
      pattern: "canModerateContent"
---

<objective>
Implement content moderation tools for posts and comments including edit and delete.

Purpose: Allows moderators, admins, and owners to review, edit, and delete inappropriate content. Per CONTEXT.md, this is hard delete with audit logging and silent edits (no "edited by moderator" indicator).

Output: Admin server actions for content moderation (edit + delete), post and comment moderation pages with edit/delete functionality.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-admin-moderation/10-CONTEXT.md
@.planning/phases/10-admin-moderation/10-RESEARCH.md
@src/lib/permissions.ts
@src/lib/audit-actions.ts
@src/lib/post-actions.ts
@src/lib/comment-actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Content Moderation Server Actions</name>
  <files>src/lib/admin-actions.ts</files>
  <action>
Create server actions for content moderation with audit logging:

```typescript
'use server';

import { getServerSession } from 'next-auth';
import { revalidatePath } from 'next/cache';
import { authOptions } from '@/lib/auth';
import db from '@/lib/db';
import { canModerateContent, type Role } from '@/lib/permissions';
import { logAuditEvent } from '@/lib/audit-actions';

// Edit any post (moderator+) - silent edit per CONTEXT.md
export async function editPostAsAdmin(postId: string, content: unknown) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) return { error: 'Not authenticated' };

  const userRole = session.user.role as Role;
  if (!canModerateContent(userRole)) {
    return { error: 'Not authorized - moderator role required' };
  }

  const post = await db.post.findUnique({
    where: { id: postId },
    select: { id: true, authorId: true, content: true },
  });

  if (!post) return { error: 'Post not found' };

  // Update post content (silent edit - no "edited by moderator" indicator)
  await db.post.update({
    where: { id: postId },
    data: { content },
  });

  // Log audit event
  await logAuditEvent({
    actorId: session.user.id,
    action: 'POST_EDITED',
    targetType: 'post',
    targetId: postId,
    targetOwnerId: post.authorId,
    metadata: { reason: 'Admin moderation' },
  });

  revalidatePath('/admin/posts');
  revalidatePath('/feed');
  revalidatePath(`/feed/${postId}`);
  return { success: true };
}

// Delete any post (moderator+)
export async function deletePostAsAdmin(postId: string) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) return { error: 'Not authenticated' };

  const userRole = session.user.role as Role;
  if (!canModerateContent(userRole)) {
    return { error: 'Not authorized - moderator role required' };
  }

  const post = await db.post.findUnique({
    where: { id: postId },
    select: { id: true, authorId: true },
  });

  if (!post) return { error: 'Post not found' };

  // Hard delete per CONTEXT.md
  await db.post.delete({ where: { id: postId } });

  // Log audit event
  await logAuditEvent({
    actorId: session.user.id,
    action: 'POST_DELETED',
    targetType: 'post',
    targetId: postId,
    targetOwnerId: post.authorId,
    metadata: { reason: 'Admin moderation' },
  });

  revalidatePath('/admin/posts');
  revalidatePath('/feed');
  return { success: true };
}

// Edit any comment (moderator+) - silent edit per CONTEXT.md
export async function editCommentAsAdmin(commentId: string, content: string) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) return { error: 'Not authenticated' };

  const userRole = session.user.role as Role;
  if (!canModerateContent(userRole)) {
    return { error: 'Not authorized - moderator role required' };
  }

  const comment = await db.comment.findUnique({
    where: { id: commentId },
    select: { id: true, authorId: true, postId: true, content: true },
  });

  if (!comment) return { error: 'Comment not found' };

  // Update comment content (silent edit - no "edited by moderator" indicator)
  await db.comment.update({
    where: { id: commentId },
    data: { content },
  });

  // Log audit event
  await logAuditEvent({
    actorId: session.user.id,
    action: 'COMMENT_EDITED',
    targetType: 'comment',
    targetId: commentId,
    targetOwnerId: comment.authorId,
    metadata: { postId: comment.postId },
  });

  revalidatePath('/admin/comments');
  revalidatePath(`/feed/${comment.postId}`);
  return { success: true };
}

// Delete any comment (moderator+)
export async function deleteCommentAsAdmin(commentId: string) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) return { error: 'Not authenticated' };

  const userRole = session.user.role as Role;
  if (!canModerateContent(userRole)) {
    return { error: 'Not authorized - moderator role required' };
  }

  const comment = await db.comment.findUnique({
    where: { id: commentId },
    select: { id: true, authorId: true, postId: true },
  });

  if (!comment) return { error: 'Comment not found' };

  // Hard delete per CONTEXT.md
  await db.comment.delete({ where: { id: commentId } });

  // Log audit event
  await logAuditEvent({
    actorId: session.user.id,
    action: 'COMMENT_DELETED',
    targetType: 'comment',
    targetId: commentId,
    targetOwnerId: comment.authorId,
    metadata: { postId: comment.postId },
  });

  revalidatePath('/admin/comments');
  revalidatePath(`/feed/${comment.postId}`);
  return { success: true };
}

// Get posts for moderation (with pagination)
export async function getPostsForModeration(page: number = 1, pageSize: number = 20) {
  const skip = (page - 1) * pageSize;

  const [posts, total] = await Promise.all([
    db.post.findMany({
      skip,
      take: pageSize,
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        content: true,
        createdAt: true,
        author: {
          select: { id: true, name: true, email: true, role: true },
        },
        category: {
          select: { id: true, name: true, color: true },
        },
        _count: {
          select: { comments: true, likes: true },
        },
      },
    }),
    db.post.count(),
  ]);

  return {
    posts,
    total,
    page,
    pageSize,
    totalPages: Math.ceil(total / pageSize),
  };
}

// Get comments for moderation (with pagination)
export async function getCommentsForModeration(page: number = 1, pageSize: number = 20) {
  const skip = (page - 1) * pageSize;

  const [comments, total] = await Promise.all([
    db.comment.findMany({
      skip,
      take: pageSize,
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        content: true,
        createdAt: true,
        author: {
          select: { id: true, name: true, email: true, role: true },
        },
        post: {
          select: { id: true },
        },
        _count: {
          select: { likes: true },
        },
      },
    }),
    db.comment.count(),
  ]);

  return {
    comments,
    total,
    page,
    pageSize,
    totalPages: Math.ceil(total / pageSize),
  };
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - no TypeScript errors.</verify>
  <done>admin-actions.ts exports editPostAsAdmin, deletePostAsAdmin, editCommentAsAdmin, deleteCommentAsAdmin, getPostsForModeration, getCommentsForModeration.</done>
</task>

<task type="auto">
  <name>Task 2: Create Post Moderation Page with Edit/Delete</name>
  <files>src/app/(main)/admin/posts/page.tsx, src/components/admin/post-table.tsx, src/components/admin/edit-post-dialog.tsx</files>
  <action>
**Create src/components/admin/edit-post-dialog.tsx:**

```typescript
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { editPostAsAdmin } from '@/lib/admin-actions';
import { toast } from 'sonner';

interface EditPostDialogProps {
  postId: string;
  initialContent: unknown;
  onClose: () => void;
}

export function EditPostDialog({ postId, initialContent, onClose }: EditPostDialogProps) {
  // Extract text from Tiptap JSON for simple editing
  const getTextFromContent = (content: unknown): string => {
    if (!content || typeof content !== 'object') return '';
    const json = content as { content?: Array<{ content?: Array<{ text?: string }> }> };
    return json.content
      ?.flatMap((node) => node.content?.map((c) => c.text) ?? [])
      .join('\n') ?? '';
  };

  const [text, setText] = useState(getTextFromContent(initialContent));
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Convert plain text back to Tiptap JSON format
  const textToContent = (plainText: string) => ({
    type: 'doc',
    content: plainText.split('\n').filter(Boolean).map((paragraph) => ({
      type: 'paragraph',
      content: [{ type: 'text', text: paragraph }],
    })),
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!text.trim()) {
      toast.error('Content cannot be empty');
      return;
    }

    setIsSubmitting(true);
    const result = await editPostAsAdmin(postId, textToContent(text.trim()));
    setIsSubmitting(false);

    if (result.error) {
      toast.error(result.error);
    } else {
      toast.success('Post updated');
      onClose();
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="absolute inset-0 bg-black/50" onClick={onClose} />
      <div className="relative bg-background rounded-lg shadow-lg p-6 w-full max-w-lg mx-4">
        <h2 className="text-lg font-semibold mb-4">Edit Post</h2>
        <p className="text-sm text-muted-foreground mb-4">
          This is a silent edit - no "edited by moderator" indicator will be shown.
        </p>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-1">
              Content
            </label>
            <textarea
              value={text}
              onChange={(e) => setText(e.target.value)}
              className="w-full px-3 py-2 border rounded-md text-sm min-h-[150px] resize-none"
              placeholder="Post content..."
              required
            />
          </div>
          <div className="flex justify-end gap-2 pt-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button type="submit" disabled={isSubmitting}>
              {isSubmitting ? 'Saving...' : 'Save Changes'}
            </Button>
          </div>
        </form>
      </div>
    </div>
  );
}
```

**Create src/components/admin/post-table.tsx:**

```typescript
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { formatDistanceToNow } from 'date-fns';
import { Button } from '@/components/ui/button';
import { RoleBadge } from '@/components/admin/role-badge';
import { EditPostDialog } from '@/components/admin/edit-post-dialog';
import { deletePostAsAdmin } from '@/lib/admin-actions';
import { toast } from 'sonner';

interface Post {
  id: string;
  content: unknown;
  createdAt: Date;
  author: {
    id: string;
    name: string | null;
    email: string;
    role: string;
  };
  category: {
    id: string;
    name: string;
    color: string;
  } | null;
  _count: {
    comments: number;
    likes: number;
  };
}

interface PostTableProps {
  posts: Post[];
}

export function PostTable({ posts }: PostTableProps) {
  const [deletingId, setDeletingId] = useState<string | null>(null);
  const [confirmId, setConfirmId] = useState<string | null>(null);
  const [editingPost, setEditingPost] = useState<Post | null>(null);

  const handleDelete = async (postId: string) => {
    setDeletingId(postId);
    const result = await deletePostAsAdmin(postId);
    setDeletingId(null);
    setConfirmId(null);

    if (result.error) {
      toast.error(result.error);
    } else {
      toast.success('Post deleted');
    }
  };

  // Extract plain text from Tiptap JSON for preview
  const getTextPreview = (content: unknown): string => {
    if (!content || typeof content !== 'object') return '';
    const json = content as { content?: Array<{ content?: Array<{ text?: string }> }> };
    const text = json.content
      ?.flatMap((node) => node.content?.map((c) => c.text) ?? [])
      .join(' ') ?? '';
    return text.length > 100 ? text.slice(0, 100) + '...' : text;
  };

  if (posts.length === 0) {
    return (
      <p className="text-center text-muted-foreground py-8">
        No posts to moderate.
      </p>
    );
  }

  return (
    <>
      <div className="space-y-4">
        {posts.map((post) => (
          <div
            key={post.id}
            className="border rounded-lg p-4 space-y-3"
          >
            <div className="flex items-start justify-between gap-4">
              <div className="flex-1 min-w-0">
                <div className="flex items-center gap-2 text-sm">
                  <span className="font-medium">{post.author.name ?? post.author.email}</span>
                  <RoleBadge role={post.author.role} />
                  {post.category && (
                    <span
                      className="px-2 py-0.5 text-xs rounded-full"
                      style={{ backgroundColor: post.category.color + '20', color: post.category.color }}
                    >
                      {post.category.name}
                    </span>
                  )}
                  <span className="text-muted-foreground">
                    {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}
                  </span>
                </div>
                <p className="mt-1 text-sm text-muted-foreground truncate">
                  {getTextPreview(post.content)}
                </p>
                <div className="mt-2 flex items-center gap-4 text-xs text-muted-foreground">
                  <span>{post._count.likes} likes</span>
                  <span>{post._count.comments} comments</span>
                  <Link
                    href={`/feed/${post.id}`}
                    className="text-primary hover:underline"
                  >
                    View post
                  </Link>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setEditingPost(post)}
                >
                  Edit
                </Button>
                {confirmId === post.id ? (
                  <>
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => handleDelete(post.id)}
                      disabled={deletingId === post.id}
                    >
                      {deletingId === post.id ? 'Deleting...' : 'Confirm'}
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setConfirmId(null)}
                    >
                      Cancel
                    </Button>
                  </>
                ) : (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setConfirmId(post.id)}
                  >
                    Delete
                  </Button>
                )}
              </div>
            </div>
          </div>
        ))}
      </div>

      {editingPost && (
        <EditPostDialog
          postId={editingPost.id}
          initialContent={editingPost.content}
          onClose={() => setEditingPost(null)}
        />
      )}
    </>
  );
}
```

**Create src/app/(main)/admin/posts/page.tsx:**

```typescript
import { Metadata } from 'next';
import { redirect } from 'next/navigation';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import db from '@/lib/db';
import { canModerateContent, type Role } from '@/lib/permissions';
import { PostTable } from '@/components/admin/post-table';
import { Pagination } from '@/components/ui/pagination';

export const metadata: Metadata = {
  title: 'Post Moderation | Admin',
};

interface PageProps {
  searchParams: Promise<{ page?: string }>;
}

export default async function AdminPostsPage({ searchParams }: PageProps) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) redirect('/login');

  const user = await db.user.findUnique({
    where: { id: session.user.id },
    select: { role: true },
  });

  const userRole = (user?.role ?? 'member') as Role;
  if (!canModerateContent(userRole)) {
    redirect('/feed?error=unauthorized');
  }

  const params = await searchParams;
  const page = Math.max(1, parseInt(params.page ?? '1', 10));
  const pageSize = 20;
  const skip = (page - 1) * pageSize;

  const [posts, total] = await Promise.all([
    db.post.findMany({
      skip,
      take: pageSize,
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        content: true,
        createdAt: true,
        author: {
          select: { id: true, name: true, email: true, role: true },
        },
        category: {
          select: { id: true, name: true, color: true },
        },
        _count: {
          select: { comments: true, likes: true },
        },
      },
    }),
    db.post.count(),
  ]);

  const totalPages = Math.ceil(total / pageSize);

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-xl font-semibold">Post Moderation</h2>
          <p className="text-sm text-muted-foreground">
            {total} total posts
          </p>
        </div>
      </div>

      <PostTable posts={posts} />

      {totalPages > 1 && (
        <Pagination
          currentPage={page}
          totalPages={totalPages}
          baseUrl="/admin/posts"
        />
      )}
    </div>
  );
}
```
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Visit /admin/posts as moderator - see list of posts
3. Click Edit on a post - edit dialog opens with current content
4. Save edit - post content updates, toast shown
5. Click Delete on a post - confirmation appears
6. Confirm delete - post is removed, toast shown
7. Check database for audit log entries (POST_EDITED, POST_DELETED)
  </verify>
  <done>Post moderation page shows all posts with edit and delete functionality, both actions logged to audit log.</done>
</task>

<task type="auto">
  <name>Task 3: Create Comment Moderation Page with Edit/Delete</name>
  <files>src/app/(main)/admin/comments/page.tsx, src/components/admin/comment-table.tsx, src/components/admin/edit-comment-dialog.tsx</files>
  <action>
**Create src/components/admin/edit-comment-dialog.tsx:**

```typescript
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { editCommentAsAdmin } from '@/lib/admin-actions';
import { toast } from 'sonner';

interface EditCommentDialogProps {
  commentId: string;
  initialContent: string;
  onClose: () => void;
}

export function EditCommentDialog({ commentId, initialContent, onClose }: EditCommentDialogProps) {
  const [content, setContent] = useState(initialContent);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!content.trim()) {
      toast.error('Content cannot be empty');
      return;
    }

    setIsSubmitting(true);
    const result = await editCommentAsAdmin(commentId, content.trim());
    setIsSubmitting(false);

    if (result.error) {
      toast.error(result.error);
    } else {
      toast.success('Comment updated');
      onClose();
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="absolute inset-0 bg-black/50" onClick={onClose} />
      <div className="relative bg-background rounded-lg shadow-lg p-6 w-full max-w-lg mx-4">
        <h2 className="text-lg font-semibold mb-4">Edit Comment</h2>
        <p className="text-sm text-muted-foreground mb-4">
          This is a silent edit - no "edited by moderator" indicator will be shown.
        </p>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-1">
              Content
            </label>
            <textarea
              value={content}
              onChange={(e) => setContent(e.target.value)}
              className="w-full px-3 py-2 border rounded-md text-sm min-h-[100px] resize-none"
              placeholder="Comment content..."
              required
            />
          </div>
          <div className="flex justify-end gap-2 pt-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button type="submit" disabled={isSubmitting}>
              {isSubmitting ? 'Saving...' : 'Save Changes'}
            </Button>
          </div>
        </form>
      </div>
    </div>
  );
}
```

**Create src/components/admin/comment-table.tsx:**

```typescript
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { formatDistanceToNow } from 'date-fns';
import { Button } from '@/components/ui/button';
import { RoleBadge } from '@/components/admin/role-badge';
import { EditCommentDialog } from '@/components/admin/edit-comment-dialog';
import { deleteCommentAsAdmin } from '@/lib/admin-actions';
import { toast } from 'sonner';

interface Comment {
  id: string;
  content: string;
  createdAt: Date;
  author: {
    id: string;
    name: string | null;
    email: string;
    role: string;
  };
  post: {
    id: string;
  };
  _count: {
    likes: number;
  };
}

interface CommentTableProps {
  comments: Comment[];
}

export function CommentTable({ comments }: CommentTableProps) {
  const [deletingId, setDeletingId] = useState<string | null>(null);
  const [confirmId, setConfirmId] = useState<string | null>(null);
  const [editingComment, setEditingComment] = useState<Comment | null>(null);

  const handleDelete = async (commentId: string) => {
    setDeletingId(commentId);
    const result = await deleteCommentAsAdmin(commentId);
    setDeletingId(null);
    setConfirmId(null);

    if (result.error) {
      toast.error(result.error);
    } else {
      toast.success('Comment deleted');
    }
  };

  if (comments.length === 0) {
    return (
      <p className="text-center text-muted-foreground py-8">
        No comments to moderate.
      </p>
    );
  }

  return (
    <>
      <div className="space-y-4">
        {comments.map((comment) => (
          <div
            key={comment.id}
            className="border rounded-lg p-4 space-y-3"
          >
            <div className="flex items-start justify-between gap-4">
              <div className="flex-1 min-w-0">
                <div className="flex items-center gap-2 text-sm">
                  <span className="font-medium">{comment.author.name ?? comment.author.email}</span>
                  <RoleBadge role={comment.author.role} />
                  <span className="text-muted-foreground">
                    {formatDistanceToNow(new Date(comment.createdAt), { addSuffix: true })}
                  </span>
                </div>
                <p className="mt-1 text-sm">
                  {comment.content.length > 200
                    ? comment.content.slice(0, 200) + '...'
                    : comment.content}
                </p>
                <div className="mt-2 flex items-center gap-4 text-xs text-muted-foreground">
                  <span>{comment._count.likes} likes</span>
                  <Link
                    href={`/feed/${comment.post.id}`}
                    className="text-primary hover:underline"
                  >
                    View post
                  </Link>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setEditingComment(comment)}
                >
                  Edit
                </Button>
                {confirmId === comment.id ? (
                  <>
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => handleDelete(comment.id)}
                      disabled={deletingId === comment.id}
                    >
                      {deletingId === comment.id ? 'Deleting...' : 'Confirm'}
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setConfirmId(null)}
                    >
                      Cancel
                    </Button>
                  </>
                ) : (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setConfirmId(comment.id)}
                  >
                    Delete
                  </Button>
                )}
              </div>
            </div>
          </div>
        ))}
      </div>

      {editingComment && (
        <EditCommentDialog
          commentId={editingComment.id}
          initialContent={editingComment.content}
          onClose={() => setEditingComment(null)}
        />
      )}
    </>
  );
}
```

**Create src/app/(main)/admin/comments/page.tsx:**

```typescript
import { Metadata } from 'next';
import { redirect } from 'next/navigation';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import db from '@/lib/db';
import { canModerateContent, type Role } from '@/lib/permissions';
import { CommentTable } from '@/components/admin/comment-table';
import { Pagination } from '@/components/ui/pagination';

export const metadata: Metadata = {
  title: 'Comment Moderation | Admin',
};

interface PageProps {
  searchParams: Promise<{ page?: string }>;
}

export default async function AdminCommentsPage({ searchParams }: PageProps) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) redirect('/login');

  const user = await db.user.findUnique({
    where: { id: session.user.id },
    select: { role: true },
  });

  const userRole = (user?.role ?? 'member') as Role;
  if (!canModerateContent(userRole)) {
    redirect('/feed?error=unauthorized');
  }

  const params = await searchParams;
  const page = Math.max(1, parseInt(params.page ?? '1', 10));
  const pageSize = 20;
  const skip = (page - 1) * pageSize;

  const [comments, total] = await Promise.all([
    db.comment.findMany({
      skip,
      take: pageSize,
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        content: true,
        createdAt: true,
        author: {
          select: { id: true, name: true, email: true, role: true },
        },
        post: {
          select: { id: true },
        },
        _count: {
          select: { likes: true },
        },
      },
    }),
    db.comment.count(),
  ]);

  const totalPages = Math.ceil(total / pageSize);

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-xl font-semibold">Comment Moderation</h2>
          <p className="text-sm text-muted-foreground">
            {total} total comments
          </p>
        </div>
      </div>

      <CommentTable comments={comments} />

      {totalPages > 1 && (
        <Pagination
          currentPage={page}
          totalPages={totalPages}
          baseUrl="/admin/comments"
        />
      )}
    </div>
  );
}
```
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Visit /admin/comments as moderator - see list of comments
3. Click Edit on a comment - edit dialog opens with current content
4. Save edit - comment content updates, toast shown
5. Click Delete on a comment - confirmation appears
6. Confirm delete - comment is removed, toast shown
7. Check database for audit log entries (COMMENT_EDITED, COMMENT_DELETED)
  </verify>
  <done>Comment moderation page shows all comments with edit and delete functionality, both actions logged to audit log.</done>
</task>

</tasks>

<verification>
1. /admin/posts shows paginated list of all posts
2. /admin/comments shows paginated list of all comments
3. Moderator can edit posts (silent edit, no indicator shown to users)
4. Moderator can delete posts (hard delete)
5. Moderator can edit comments (silent edit, no indicator shown to users)
6. Moderator can delete comments (hard delete)
7. Delete requires confirmation (inline, not modal)
8. All edit and delete actions create audit log entries
9. Toast notifications confirm successful actions
10. Pagination works correctly on both pages
</verification>

<success_criteria>
- Owner/Admin/Moderator can access /admin/posts and /admin/comments
- Post table shows author, preview, likes, comments count, timestamp, Edit button, Delete button
- Comment table shows author, content preview, likes, timestamp, Edit button, Delete button
- Edit action opens dialog, saves silently (no "edited by moderator" indicator per CONTEXT.md)
- Delete action requires confirmation, then performs hard delete
- Audit log entry created for every moderation action (POST_EDITED, POST_DELETED, COMMENT_EDITED, COMMENT_DELETED)
- Pages support pagination for large datasets
</success_criteria>

<output>
After completion, create `.planning/phases/10-admin-moderation/10-02-SUMMARY.md`
</output>
