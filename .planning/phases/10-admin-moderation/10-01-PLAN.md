---
phase: 10-admin-moderation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/permissions.ts
  - src/lib/auth.ts
  - src/lib/audit-actions.ts
  - src/components/admin/role-badge.tsx
  - src/components/admin/admin-tabs.tsx
  - src/app/(main)/admin/layout.tsx
  - src/app/(main)/admin/page.tsx
autonomous: true

must_haves:
  truths:
    - "Role hierarchy exists: Owner > Admin > Moderator > Member"
    - "User role is available in session after login"
    - "Admin dashboard is accessible only to users with admin/owner/moderator roles"
    - "Role badges display on user content (posts, comments, profiles)"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Ban, AuditLog, CommunitySettings models"
      contains: "model Ban"
    - path: "src/lib/permissions.ts"
      provides: "Role hierarchy helpers"
      exports: ["ROLE_HIERARCHY", "canManageRole", "canModerateContent", "canManageMembers", "canEditSettings"]
    - path: "src/lib/auth.ts"
      provides: "Role in JWT and session"
      contains: "role: string"
    - path: "src/components/admin/role-badge.tsx"
      provides: "Visual role indicator"
      exports: ["RoleBadge"]
    - path: "src/app/(main)/admin/layout.tsx"
      provides: "Admin section layout with tabs"
  key_links:
    - from: "src/lib/auth.ts"
      to: "prisma/schema.prisma"
      via: "db.user.findUnique for role"
      pattern: "select:.*role"
    - from: "src/app/(main)/admin/layout.tsx"
      to: "src/lib/permissions.ts"
      via: "Role check for access"
      pattern: "canModerateContent|role.*moderator"
---

<objective>
Establish the role system foundation for admin and moderation features.

Purpose: This plan creates the database schema, permission helpers, and session infrastructure that all subsequent admin plans depend on. Without this foundation, content moderation and member management cannot be implemented.

Output: Ban/AuditLog/CommunitySettings models, permissions.ts with role hierarchy, role in session, RoleBadge component, admin layout with tabs.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-admin-moderation/10-CONTEXT.md
@.planning/phases/10-admin-moderation/10-RESEARCH.md
@prisma/schema.prisma
@src/lib/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Admin Models to Schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add three new models to the Prisma schema:

1. **Ban model** - For temporary user restrictions:
```prisma
model Ban {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation("UserBans", fields: [userId], references: [id], onDelete: Cascade)
  reason     String   @db.VarChar(500)
  expiresAt  DateTime @db.Timestamptz(3)
  bannedById String
  bannedBy   User     @relation("BannedByUser", fields: [bannedById], references: [id])
  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
}
```

2. **AuditLog model** - For tracking moderation actions:
```prisma
model AuditLog {
  id            String   @id @default(cuid())
  actorId       String
  actor         User     @relation(fields: [actorId], references: [id])
  action        String   // POST_DELETED, COMMENT_DELETED, MEMBER_BANNED, MEMBER_REMOVED, etc.
  targetType    String   // post, comment, user
  targetId      String
  targetOwnerId String?  // For notifications
  metadata      Json?    // Additional context (ban reason, etc.)
  createdAt     DateTime @default(now())

  @@index([actorId])
  @@index([targetType, targetId])
  @@index([createdAt])
}
```

3. **CommunitySettings model** - Singleton for community configuration:
```prisma
model CommunitySettings {
  id          String  @id @default("singleton")
  name        String  @default("Community")
  description String? @db.Text
  logo        String? // Supabase storage URL

  updatedAt   DateTime @updatedAt
}
```

Also add relations to User model:
```prisma
// Add to User model relations
bans         Ban[]       @relation("UserBans")
bannedUsers  Ban[]       @relation("BannedByUser")
auditLogs    AuditLog[]
```

Run `npx prisma db push` to apply schema changes.
  </action>
  <verify>Run `npx prisma db push` - should complete without errors. Check that models appear in Prisma Studio.</verify>
  <done>Ban, AuditLog, and CommunitySettings models exist in schema and database.</done>
</task>

<task type="auto">
  <name>Task 2: Create Permissions and Audit Helpers</name>
  <files>src/lib/permissions.ts, src/lib/audit-actions.ts</files>
  <action>
**Create src/lib/permissions.ts:**

```typescript
// Role hierarchy with numeric levels for comparison
export const ROLE_HIERARCHY = {
  owner: 4,
  admin: 3,
  moderator: 2,
  member: 1,
} as const;

export type Role = keyof typeof ROLE_HIERARCHY;

// Check if actor can manage target (actor must be higher in hierarchy)
export function canManageRole(actorRole: Role, targetRole: Role): boolean {
  return ROLE_HIERARCHY[actorRole] > ROLE_HIERARCHY[targetRole];
}

// Moderator+ can edit/delete posts and comments
export function canModerateContent(role: Role): boolean {
  return ROLE_HIERARCHY[role] >= ROLE_HIERARCHY.moderator;
}

// Admin+ can manage members (ban, remove, change roles)
export function canManageMembers(role: Role): boolean {
  return ROLE_HIERARCHY[role] >= ROLE_HIERARCHY.admin;
}

// Only owner can edit community settings
export function canEditSettings(role: Role): boolean {
  return role === 'owner';
}

// Check if actor can assign a specific role
export function canAssignRole(actorRole: Role, newRole: Role): boolean {
  // Owner can assign any role except owner (there's only one owner)
  if (actorRole === 'owner') return newRole !== 'owner';
  // Admin can only assign/remove moderator
  if (actorRole === 'admin') return newRole === 'moderator' || newRole === 'member';
  return false;
}

// Check if role is valid
export function isValidRole(role: string): role is Role {
  return role in ROLE_HIERARCHY;
}
```

**Create src/lib/audit-actions.ts:**

```typescript
'use server';

import db from '@/lib/db';

export type AuditAction =
  | 'POST_DELETED'
  | 'POST_EDITED'
  | 'COMMENT_DELETED'
  | 'COMMENT_EDITED'
  | 'MEMBER_BANNED'
  | 'MEMBER_REMOVED'
  | 'MEMBER_ROLE_CHANGED'
  | 'SETTINGS_UPDATED';

export async function logAuditEvent(event: {
  actorId: string;
  action: AuditAction;
  targetType: 'post' | 'comment' | 'user' | 'settings';
  targetId: string;
  targetOwnerId?: string;
  metadata?: Record<string, unknown>;
}) {
  return db.auditLog.create({
    data: {
      actorId: event.actorId,
      action: event.action,
      targetType: event.targetType,
      targetId: event.targetId,
      targetOwnerId: event.targetOwnerId,
      metadata: event.metadata ?? {},
    },
  });
}

export async function getAuditLogs(options?: {
  targetType?: string;
  targetId?: string;
  limit?: number;
}) {
  return db.auditLog.findMany({
    where: {
      ...(options?.targetType && { targetType: options.targetType }),
      ...(options?.targetId && { targetId: options.targetId }),
    },
    orderBy: { createdAt: 'desc' },
    take: options?.limit ?? 50,
    include: {
      actor: {
        select: { id: true, name: true, email: true },
      },
    },
  });
}
```
  </action>
  <verify>TypeScript compilation succeeds with no errors. Run `npx tsc --noEmit` to verify.</verify>
  <done>permissions.ts exports all role hierarchy functions, audit-actions.ts exports logAuditEvent and getAuditLogs.</done>
</task>

<task type="auto">
  <name>Task 3: Extend Auth with Role and Create Admin UI Shell</name>
  <files>src/lib/auth.ts, src/components/admin/role-badge.tsx, src/components/admin/admin-tabs.tsx, src/app/(main)/admin/layout.tsx, src/app/(main)/admin/page.tsx</files>
  <action>
**Update src/lib/auth.ts:**

Extend the type declarations and callbacks to include role:

```typescript
// Update Session interface to include role
declare module 'next-auth' {
  interface Session {
    user: {
      id: string;
      role: string;  // Add this
      name?: string | null;
      email?: string | null;
      image?: string | null;
    };
  }
}

declare module 'next-auth/jwt' {
  interface JWT {
    id: string;
    role: string;  // Add this
  }
}

// Update jwt callback to fetch and store role:
async jwt({ token, user, trigger }) {
  if (user) {
    token.id = user.id;
    // Fetch role from database
    const dbUser = await db.user.findUnique({
      where: { id: user.id },
      select: { role: true },
    });
    token.role = dbUser?.role ?? 'member';
  }
  // Handle role updates (when update() is called on session)
  if (trigger === 'update') {
    const dbUser = await db.user.findUnique({
      where: { id: token.id as string },
      select: { role: true },
    });
    token.role = dbUser?.role ?? 'member';
  }
  return token;
}

// Update session callback to include role:
async session({ session, token }) {
  if (session.user) {
    session.user.id = token.id as string;
    session.user.role = token.role as string;
  }
  return session;
}
```

**Create src/components/admin/role-badge.tsx:**

```typescript
import { cn } from '@/lib/utils';

const ROLE_STYLES = {
  owner: 'bg-amber-100 text-amber-800 border-amber-200',
  admin: 'bg-purple-100 text-purple-800 border-purple-200',
  moderator: 'bg-blue-100 text-blue-800 border-blue-200',
  member: 'bg-gray-100 text-gray-800 border-gray-200',
} as const;

const ROLE_LABELS = {
  owner: 'Owner',
  admin: 'Admin',
  moderator: 'Mod',
  member: 'Member',
} as const;

interface RoleBadgeProps {
  role: string;
  showMember?: boolean;
  className?: string;
}

export function RoleBadge({ role, showMember = false, className }: RoleBadgeProps) {
  // Don't show member badge unless explicitly requested
  if (role === 'member' && !showMember) return null;

  const style = ROLE_STYLES[role as keyof typeof ROLE_STYLES] ?? ROLE_STYLES.member;
  const label = ROLE_LABELS[role as keyof typeof ROLE_LABELS] ?? 'Member';

  return (
    <span
      className={cn(
        'inline-flex items-center px-2 py-0.5 text-xs font-medium rounded-full border',
        style,
        className
      )}
    >
      {label}
    </span>
  );
}
```

**Create src/components/admin/admin-tabs.tsx:**

```typescript
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { cn } from '@/lib/utils';
import { ROLE_HIERARCHY, type Role } from '@/lib/permissions';

const TABS = [
  { id: 'members', label: 'Members', href: '/admin/members', minRole: 'admin' as Role },
  { id: 'posts', label: 'Posts', href: '/admin/posts', minRole: 'moderator' as Role },
  { id: 'comments', label: 'Comments', href: '/admin/comments', minRole: 'moderator' as Role },
  { id: 'settings', label: 'Settings', href: '/admin/settings', minRole: 'owner' as Role },
] as const;

interface AdminTabsProps {
  userRole: string;
}

export function AdminTabs({ userRole }: AdminTabsProps) {
  const pathname = usePathname();

  const roleLevel = ROLE_HIERARCHY[userRole as Role] ?? 0;
  const visibleTabs = TABS.filter(
    (tab) => roleLevel >= ROLE_HIERARCHY[tab.minRole]
  );

  return (
    <div className="flex gap-1 p-1 bg-muted rounded-lg">
      {visibleTabs.map((tab) => (
        <Link
          key={tab.id}
          href={tab.href}
          className={cn(
            'px-4 py-2 text-sm font-medium rounded-md transition-colors',
            pathname.startsWith(tab.href)
              ? 'bg-background text-foreground shadow-sm'
              : 'text-muted-foreground hover:text-foreground'
          )}
        >
          {tab.label}
        </Link>
      ))}
    </div>
  );
}
```

**Create src/app/(main)/admin/layout.tsx:**

```typescript
import { redirect } from 'next/navigation';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import db from '@/lib/db';
import { AdminTabs } from '@/components/admin/admin-tabs';
import { ROLE_HIERARCHY, type Role } from '@/lib/permissions';

export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) redirect('/login');

  const user = await db.user.findUnique({
    where: { id: session.user.id },
    select: { role: true },
  });

  const userRole = (user?.role ?? 'member') as Role;

  // Only moderator+ can access /admin
  if (ROLE_HIERARCHY[userRole] < ROLE_HIERARCHY.moderator) {
    redirect('/feed?error=unauthorized');
  }

  return (
    <div className="max-w-6xl mx-auto space-y-6">
      <div>
        <h1 className="text-3xl font-bold">Admin Dashboard</h1>
        <p className="text-muted-foreground mt-1">
          Manage community content and members
        </p>
      </div>

      <AdminTabs userRole={userRole} />

      {children}
    </div>
  );
}
```

**Update src/app/(main)/admin/page.tsx:**

```typescript
import { redirect } from 'next/navigation';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import db from '@/lib/db';
import { ROLE_HIERARCHY, type Role } from '@/lib/permissions';

export default async function AdminPage() {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) redirect('/login');

  const user = await db.user.findUnique({
    where: { id: session.user.id },
    select: { role: true },
  });

  const userRole = (user?.role ?? 'member') as Role;

  // Redirect to appropriate default tab based on role
  if (ROLE_HIERARCHY[userRole] >= ROLE_HIERARCHY.admin) {
    redirect('/admin/members');
  } else if (ROLE_HIERARCHY[userRole] >= ROLE_HIERARCHY.moderator) {
    redirect('/admin/posts');
  }

  redirect('/feed?error=unauthorized');
}
```
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Run `npm run build` - builds successfully
3. Visit /admin while logged in as admin - should see tabs and redirect to /admin/members or /admin/posts
  </verify>
  <done>Role is included in session, RoleBadge component works, admin layout with tabs is functional and role-gated.</done>
</task>

</tasks>

<verification>
1. Database schema includes Ban, AuditLog, and CommunitySettings models
2. `npx prisma db push` succeeds
3. permissions.ts exports all role hierarchy functions
4. audit-actions.ts exports logAuditEvent and getAuditLogs
5. Session includes user.role after login
6. /admin route redirects unauthorized users to /feed
7. Admin tabs show correct tabs based on user role
8. RoleBadge renders with correct styling for each role
</verification>

<success_criteria>
- Role hierarchy (Owner > Admin > Moderator > Member) is enforced via permissions.ts
- Session includes role, accessible via session.user.role
- Admin layout at /admin is only accessible to moderator+
- Tabs show/hide based on user's role level
- RoleBadge component displays role with appropriate styling
- Database has Ban, AuditLog, CommunitySettings tables ready for use
</success_criteria>

<output>
After completion, create `.planning/phases/10-admin-moderation/10-01-SUMMARY.md`
</output>
