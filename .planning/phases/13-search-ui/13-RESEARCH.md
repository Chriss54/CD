# Phase 13: Search UI & Results - Research

**Researched:** 2026-01-24
**Domain:** Next.js App Router search UI with URL state management
**Confidence:** HIGH

## Summary

This phase builds the user-facing search interface on top of the search infrastructure completed in Phase 12. The primary patterns involve:

1. A client-side `SearchBar` component in the header with keyboard shortcut support (Cmd+K / Ctrl+K)
2. A `/search` page that reads query params and calls the existing `search()` server action
3. URL-based state for query (`?q=`) and type filter (`?type=`) enabling shareable, bookmarkable searches
4. Result cards with highlighted snippets using the `<mark>` tags already generated by PostgreSQL's `ts_headline`

The existing codebase provides excellent patterns to follow: `LeaderboardTabs` for URL-based tab filtering, `CategoryTabs` for horizontal tab navigation, `EmptyState` for empty/error states, and `MemberCard`/`CourseCatalogCard` for result card layouts.

**Primary recommendation:** Use `use-debounce` for input debouncing, native `useEffect` for keyboard shortcuts (no external library needed), and `useSearchParams` with `router.push()` for URL state management following the established project patterns.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `use-debounce` | 10.x | Debounce search input | Official Next.js tutorial recommendation, <1KB, simple API |
| `next/navigation` | (bundled) | URL state management | Built-in `useSearchParams`, `useRouter`, `usePathname` |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `react` | 19.x | `useEffect` for keyboard shortcuts | Native hook sufficient for Cmd+K binding |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| `use-debounce` | `lodash.debounce` | use-debounce is smaller, React-specific, hooks-based |
| Native `useEffect` | `react-hotkeys-hook`, `tinykeys` | External deps unnecessary for single shortcut |
| `useSearchParams` | `nuqs` | nuqs adds type-safety but overkill for simple string params |

**Installation:**
```bash
npm install use-debounce
```

## Architecture Patterns

### Recommended Project Structure
```
src/
â”œâ”€â”€ components/
â”‚   â””â”€â”€ search/
â”‚       â”œâ”€â”€ search-bar.tsx          # Client component for header
â”‚       â”œâ”€â”€ search-results.tsx      # Results list with type filtering
â”‚       â”œâ”€â”€ search-result-card.tsx  # Individual result card
â”‚       â””â”€â”€ search-tabs.tsx         # Type filter tabs (All/Posts/Members/Courses)
â”œâ”€â”€ app/(main)/
â”‚   â””â”€â”€ search/
â”‚       â””â”€â”€ page.tsx                # Search results page
â””â”€â”€ lib/
    â””â”€â”€ search-actions.ts           # (EXISTS) Server action from Phase 12
```

### Pattern 1: Search Input with URL Navigation
**What:** Client component that debounces input and navigates to search page on Enter
**When to use:** Header search bar that triggers full-page navigation
**Example:**
```typescript
// Source: Next.js official tutorial pattern
'use client';

import { useRouter } from 'next/navigation';
import { useDebouncedCallback } from 'use-debounce';
import { useState, useEffect, useRef } from 'react';

export function SearchBar() {
  const router = useRouter();
  const inputRef = useRef<HTMLInputElement>(null);
  const [query, setQuery] = useState('');

  // Keyboard shortcut: Cmd+K / Ctrl+K
  useEffect(() => {
    function handleKeyDown(e: KeyboardEvent) {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        inputRef.current?.focus();
      }
    }
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, []);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (query.trim()) {
      router.push(`/search?q=${encodeURIComponent(query.trim())}`);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        ref={inputRef}
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search... âŒ˜K"
        className="..."
      />
    </form>
  );
}
```

### Pattern 2: URL-Based Tab Filtering
**What:** Tabs that update URL search params without full page reload
**When to use:** Type filter tabs on search results page
**Example:**
```typescript
// Source: Existing LeaderboardTabs pattern in codebase
'use client';

import Link from 'next/link';
import { useSearchParams } from 'next/navigation';
import { cn } from '@/lib/utils';

const TYPES = [
  { id: 'all', label: 'All' },
  { id: 'post', label: 'Posts' },
  { id: 'user', label: 'Members' },
  { id: 'course', label: 'Courses' },
] as const;

export function SearchTabs({ counts }: { counts: Record<string, number> }) {
  const searchParams = useSearchParams();
  const currentType = searchParams.get('type') || 'all';
  const query = searchParams.get('q') || '';

  return (
    <div className="flex gap-1 p-1 bg-muted rounded-lg">
      {TYPES.map((type) => (
        <Link
          key={type.id}
          href={`/search?q=${encodeURIComponent(query)}${type.id !== 'all' ? `&type=${type.id}` : ''}`}
          className={cn(
            'px-4 py-2 text-sm font-medium rounded-md transition-colors',
            currentType === type.id
              ? 'bg-background text-foreground shadow-sm'
              : 'text-muted-foreground hover:text-foreground'
          )}
        >
          {type.label} ({counts[type.id] || 0})
        </Link>
      ))}
    </div>
  );
}
```

### Pattern 3: Server Component with searchParams
**What:** Page component that reads URL params and fetches data server-side
**When to use:** Search results page
**Example:**
```typescript
// Source: Next.js App Router pattern, matches existing feed/page.tsx
import { Suspense } from 'react';
import { search } from '@/lib/search-actions';

interface SearchPageProps {
  searchParams: Promise<{ q?: string; type?: string }>;
}

export default async function SearchPage({ searchParams }: SearchPageProps) {
  const params = await searchParams;
  const query = params.q || '';
  const type = params.type || 'all';

  return (
    <div className="max-w-2xl mx-auto">
      <Suspense fallback={<SearchResultsSkeleton />}>
        <SearchResults query={query} type={type} />
      </Suspense>
    </div>
  );
}
```

### Pattern 4: Snippet Highlighting with dangerouslySetInnerHTML
**What:** Render `<mark>` tags from ts_headline safely
**When to use:** Displaying search result snippets
**Example:**
```typescript
// Source: Phase 12 search-actions.ts generates <mark> tags
// CSS for mark tag defined in globals or component

<p
  className="text-sm text-muted-foreground"
  dangerouslySetInnerHTML={{ __html: result.snippet }}
/>

// Style the mark tag
// In CSS:
// mark { background-color: #fef08a; } /* yellow-200 */
```

### Anti-Patterns to Avoid
- **Controlled input synced with URL:** Don't use `value={searchParams.get('q')}` on the input - use `defaultValue` or local state. Controlled inputs cause lag when synced with URL updates.
- **Missing Suspense boundary:** Always wrap components using `useSearchParams` in Suspense for static rendering.
- **Debouncing navigation:** Don't debounce the actual navigation - debounce should only delay the URL update, not block user intent on Enter key.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Input debouncing | Custom setTimeout/clearTimeout | `use-debounce` useDebouncedCallback | Edge cases with cleanup, stale closures |
| URL param manipulation | Manual string concatenation | `URLSearchParams` API | Handles encoding, multiple params |
| Keyboard shortcuts | Custom key tracking | Native `useEffect` with keydown | Simple case doesn't need library |

**Key insight:** The search backend (Phase 12) already handles: query parsing (`websearch_to_tsquery`), highlighting (`ts_headline` with `<mark>`), ranking, and result limiting. The UI just needs to call the server action and render results.

## Common Pitfalls

### Pitfall 1: Missing Suspense Boundary
**What goes wrong:** Build fails with "Missing Suspense boundary with useSearchParams"
**Why it happens:** `useSearchParams` requires Suspense for static rendering in App Router
**How to avoid:** Wrap any component using `useSearchParams` in `<Suspense>` at the page level
**Warning signs:** Works in dev mode but fails during `npm run build`

### Pitfall 2: Input Focus Issues with Keyboard Shortcut
**What goes wrong:** Cmd+K doesn't focus input or triggers browser default
**Why it happens:** Need `e.preventDefault()` and proper ref handling
**How to avoid:** Use `useRef` for input reference, call `inputRef.current?.focus()` in handler
**Warning signs:** Browser opens bookmarks or other default Cmd+K action

### Pitfall 3: URL Encoding Issues
**What goes wrong:** Special characters in search break URLs or cause double-encoding
**Why it happens:** Manual string concatenation without proper encoding
**How to avoid:** Always use `encodeURIComponent()` for query values, use `URLSearchParams` for building query strings
**Warning signs:** Searches with `&`, `=`, or spaces produce broken URLs

### Pitfall 4: Type Badge Inconsistency
**What goes wrong:** Results show "user" but decision says "Member"
**Why it happens:** Database returns `type: 'user'` but UI should display "Member"
**How to avoid:** Map type values to display labels: `{ user: 'Member', post: 'Post', course: 'Course' }`
**Warning signs:** UI shows raw database type values

### Pitfall 5: XSS via Snippet HTML
**What goes wrong:** Malicious content in posts could inject scripts
**Why it happens:** Using `dangerouslySetInnerHTML` with untrusted content
**How to avoid:** The `ts_headline` function only adds `<mark>` tags to existing content that was already plain text. Since `plainText` is extracted from Tiptap (sanitized) and stored server-side, this is safe. However, verify `ts_headline` configuration uses only `<mark>` tags.
**Warning signs:** Snippets containing script tags or event handlers

## Code Examples

Verified patterns from official sources and existing codebase:

### Keyboard Shortcut Handler
```typescript
// Source: Standard DOM event pattern
useEffect(() => {
  function handleKeyDown(e: KeyboardEvent) {
    // Cmd+K (Mac) or Ctrl+K (Windows/Linux)
    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
      e.preventDefault();
      inputRef.current?.focus();
    }
  }
  document.addEventListener('keydown', handleKeyDown);
  return () => document.removeEventListener('keydown', handleKeyDown);
}, []);
```

### Search Result Card
```typescript
// Source: Follows MemberCard/CourseCatalogCard patterns in codebase
import Link from 'next/link';
import { cn } from '@/lib/utils';

const TYPE_CONFIG = {
  post: { label: 'Post', href: (id: string) => `/feed/${id}`, icon: 'ðŸ“' },
  user: { label: 'Member', href: (id: string) => `/members/${id}`, icon: 'ðŸ‘¤' },
  course: { label: 'Course', href: (id: string) => `/classroom/courses/${id}`, icon: 'ðŸ“š' },
};

export function SearchResultCard({ result }: { result: SearchResult }) {
  const config = TYPE_CONFIG[result.type];

  return (
    <Link
      href={config.href(result.id)}
      className={cn(
        'block border border-border rounded-lg p-4',
        'hover:shadow-md transition-shadow',
        'focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2'
      )}
    >
      <div className="flex items-start gap-3">
        <span className="text-lg">{config.icon}</span>
        <div className="min-w-0 flex-1">
          <div className="flex items-center gap-2">
            <p className="font-medium truncate">{result.title}</p>
            <span className="text-xs bg-muted px-2 py-0.5 rounded">{config.label}</span>
          </div>
          <p
            className="text-sm text-muted-foreground mt-1 line-clamp-2"
            dangerouslySetInnerHTML={{ __html: result.snippet }}
          />
        </div>
      </div>
    </Link>
  );
}
```

### Empty State for No Results
```typescript
// Source: Existing EmptyState component in codebase
import { EmptyState } from '@/components/ui/empty-state';

// No results
<EmptyState
  title={`No results for "${query}"`}
  description="Try different keywords or check your spelling."
/>

// Empty query (no search performed)
// Per CONTEXT.md: just show search input, no tips
<div className="text-center py-12 text-muted-foreground">
  Enter a search term to find posts, members, and courses.
</div>
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `useState` for search filters | URL search params | Next.js 13+ App Router | Shareable, bookmarkable searches |
| Sync searchParams (v14) | Async searchParams Promise | Next.js 15 | Must `await props.searchParams` |
| Custom debounce | `use-debounce` library | Mature ecosystem | Cleaner hooks API |

**Deprecated/outdated:**
- `router.query` from Pages Router - use `useSearchParams` in App Router
- Synchronous `searchParams` prop - Next.js 15+ requires `await`

## Open Questions

Things that couldn't be fully resolved:

1. **Header component modification**
   - What we know: Header is a Server Component (`src/components/layout/header.tsx`)
   - What's unclear: Can SearchBar be inserted directly, or does Header need to become a Client Component?
   - Recommendation: SearchBar is Client Component, can be imported into Server Component Header (client components can be children of server components). No Header modification needed beyond adding the import.

2. **Result count calculation**
   - What we know: Phase 12's `search()` returns all results (max 50), we filter client-side for tabs
   - What's unclear: Should counts be calculated server-side per type, or derive from client-side filtering?
   - Recommendation: Filter the full results array client-side and count per type. Server already limits to 50, so no performance concern.

## Sources

### Primary (HIGH confidence)
- [Next.js useSearchParams docs](https://nextjs.org/docs/app/api-reference/functions/use-search-params) - URL state patterns, Suspense requirements
- [Next.js Search Tutorial](https://nextjs.org/learn/dashboard-app/adding-search-and-pagination) - Debounce, URL state, server-side filtering
- Existing codebase patterns: `LeaderboardTabs`, `CategoryTabs`, `EmptyState`, `MemberCard`

### Secondary (MEDIUM confidence)
- [use-debounce GitHub](https://github.com/xnimorz/use-debounce) - Hook API, usage examples
- [LogRocket URL State Guide](https://blog.logrocket.com/url-state-usesearchparams/) - useSearchParams best practices

### Tertiary (LOW confidence)
- None - all patterns verified with official sources or existing codebase

## Metadata

**Confidence breakdown:**
- Standard Stack: HIGH - Official Next.js patterns, use-debounce widely adopted
- Architecture: HIGH - Follows existing codebase patterns exactly
- Pitfalls: HIGH - Documented in official docs and verified with existing code

**Research date:** 2026-01-24
**Valid until:** 2026-02-24 (30 days - stable patterns, no fast-moving dependencies)
