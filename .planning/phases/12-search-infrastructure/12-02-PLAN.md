---
phase: 12-search-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/lib/post-actions.ts
  - src/lib/search-actions.ts
  - scripts/backfill-plain-text.ts
autonomous: true

must_haves:
  truths:
    - "Creating/updating a post automatically populates plainText column"
    - "Existing posts have plainText backfilled from Tiptap content"
    - "Search query returns ranked results from Post, User, and Course"
    - "Title matches rank higher than content matches (weight A > B)"
    - "Search results include snippet with matched text context"
  artifacts:
    - path: "src/lib/post-actions.ts"
      provides: "Post CRUD with plainText extraction"
      contains: "extractPlainText"
    - path: "src/lib/search-actions.ts"
      provides: "Unified search across entities"
      exports: ["search"]
  key_links:
    - from: "src/lib/post-actions.ts"
      to: "src/lib/tiptap-utils.ts"
      via: "import extractPlainText"
      pattern: "extractPlainText.*content"
    - from: "src/lib/search-actions.ts"
      to: "prisma.$queryRaw"
      via: "FTS query execution"
      pattern: "websearch_to_tsquery"
---

<objective>
Integrate plainText extraction into post workflow and create unified search server action.

Purpose: Complete the search infrastructure by connecting Tiptap extraction to post operations, backfilling existing data, and providing a search action that queries all indexed content with ranking.

Output: Updated post-actions with plainText, backfill script, and search-actions.ts with unified FTS query.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-search-infrastructure/12-RESEARCH.md
@.planning/phases/12-search-infrastructure/12-01-SUMMARY.md

@src/lib/post-actions.ts
@src/lib/tiptap-utils.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate plainText extraction into post-actions</name>
  <files>src/lib/post-actions.ts</files>
  <action>
Update `src/lib/post-actions.ts` to extract plainText from Tiptap content on create and update operations.

1. Import the extraction utility:
   ```typescript
   import { extractPlainText } from '@/lib/tiptap-utils';
   ```

2. In `createPost()`, after validation, extract plainText before creating:
   ```typescript
   const plainText = extractPlainText(content);

   await db.post.create({
     data: {
       content: content as Prisma.InputJsonValue,
       embeds: embeds as Prisma.InputJsonValue,
       plainText,  // Add this field
       authorId: session.user.id,
     },
   });
   ```

3. In `updatePost()`, do the same:
   ```typescript
   const plainText = extractPlainText(content);

   await db.post.update({
     where: { id: postId },
     data: {
       content: content as Prisma.InputJsonValue,
       embeds: embeds as Prisma.InputJsonValue,
       plainText,  // Add this field
     },
   });
   ```

This ensures all new/updated posts have plainText populated, which triggers the GENERATED searchVector column to auto-update.
  </action>
  <verify>
1. Run `npx tsc --noEmit` to verify TypeScript compiles
2. Create a test post via the UI, then verify in database:
   ```sql
   SELECT id, "plainText", "searchVector" IS NOT NULL as has_vector
   FROM "Post" ORDER BY "createdAt" DESC LIMIT 1;
   ```
   The plainText should contain the extracted text and has_vector should be true.
  </verify>
  <done>
createPost and updatePost in post-actions.ts call extractPlainText and save to plainText column. New posts have searchVector auto-populated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create backfill script for existing posts</name>
  <files>scripts/backfill-plain-text.ts</files>
  <action>
Create `scripts/backfill-plain-text.ts` to populate plainText for all existing posts.

```typescript
import db from '../src/lib/db';
import { extractPlainText } from '../src/lib/tiptap-utils';

async function backfillPlainText() {
  console.log('Starting plainText backfill...');

  // Get all posts without plainText
  const posts = await db.post.findMany({
    where: { plainText: null },
    select: { id: true, content: true },
  });

  console.log(`Found ${posts.length} posts to backfill`);

  let updated = 0;
  for (const post of posts) {
    const plainText = extractPlainText(post.content);
    await db.post.update({
      where: { id: post.id },
      data: { plainText },
    });
    updated++;
    if (updated % 100 === 0) {
      console.log(`Updated ${updated}/${posts.length} posts`);
    }
  }

  console.log(`Backfill complete. Updated ${updated} posts.`);
}

backfillPlainText()
  .catch(console.error)
  .finally(() => db.$disconnect());
```

Run the script with `npx tsx scripts/backfill-plain-text.ts`.

Note: This uses tsx to run TypeScript directly. If tsx is not installed, add it: `npm install -D tsx`.
  </action>
  <verify>
1. Run `npx tsx scripts/backfill-plain-text.ts`
2. Verify all posts now have plainText:
   ```sql
   SELECT COUNT(*) as total, COUNT("plainText") as with_text FROM "Post";
   ```
   Both counts should be equal.
3. Verify searchVector is populated:
   ```sql
   SELECT COUNT(*) as total, COUNT("searchVector") as with_vector FROM "Post";
   ```
   Both counts should be equal.
  </verify>
  <done>
Backfill script runs successfully. All existing posts have plainText populated, which triggers searchVector auto-generation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create unified search server action</name>
  <files>src/lib/search-actions.ts</files>
  <action>
Create `src/lib/search-actions.ts` with a unified search function that queries Post, User, and Course tables using PostgreSQL FTS.

```typescript
'use server';

import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import db from '@/lib/db';

export interface SearchResult {
  id: string;
  type: 'post' | 'user' | 'course';
  title: string;
  snippet: string;
  rank: number;
}

export async function search(query: string): Promise<{ results: SearchResult[]; duration: number } | { error: string }> {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return { error: 'Not authenticated' };
  }

  // Empty query returns empty results
  if (!query.trim()) {
    return { results: [], duration: 0 };
  }

  const startTime = performance.now();

  try {
    const results = await db.$queryRaw<SearchResult[]>`
      SELECT id, 'post' as type,
             COALESCE(LEFT("plainText", 100), '') as title,
             ts_headline('english', COALESCE("plainText", ''), websearch_to_tsquery('english', ${query}),
               'MaxWords=30, MinWords=15, StartSel=<mark>, StopSel=</mark>') as snippet,
             ts_rank("searchVector", websearch_to_tsquery('english', ${query})) as rank
      FROM "Post"
      WHERE "searchVector" @@ websearch_to_tsquery('english', ${query})

      UNION ALL

      SELECT id, 'user' as type,
             COALESCE(name, 'Unknown') as title,
             ts_headline('english', COALESCE(name, '') || ' ' || COALESCE(bio, ''),
               websearch_to_tsquery('english', ${query}),
               'MaxWords=30, MinWords=15, StartSel=<mark>, StopSel=</mark>') as snippet,
             ts_rank("searchVector", websearch_to_tsquery('english', ${query})) as rank
      FROM "User"
      WHERE "searchVector" @@ websearch_to_tsquery('english', ${query})

      UNION ALL

      SELECT id, 'course' as type,
             COALESCE(title, 'Untitled') as title,
             ts_headline('english', COALESCE(title, '') || ' ' || COALESCE(description, ''),
               websearch_to_tsquery('english', ${query}),
               'MaxWords=30, MinWords=15, StartSel=<mark>, StopSel=</mark>') as snippet,
             ts_rank("searchVector", websearch_to_tsquery('english', ${query})) as rank
      FROM "Course"
      WHERE "searchVector" @@ websearch_to_tsquery('english', ${query})
        AND status = 'PUBLISHED'

      ORDER BY rank DESC
      LIMIT 50
    `;

    const duration = Math.round(performance.now() - startTime);

    return { results, duration };
  } catch (error) {
    console.error('Search error:', error);
    return { error: 'Search failed' };
  }
}
```

Key implementation details:
- Uses `websearch_to_tsquery` for user-friendly query syntax (supports quotes, OR, NOT)
- Uses `ts_rank` for relevance scoring (weight A for title > weight B for content)
- Uses `ts_headline` to generate snippets with `<mark>` tags around matches
- Returns duration in ms for monitoring the 100ms target
- Only searches PUBLISHED courses
- Posts use first 100 chars of plainText as "title" since posts don't have titles
- LIMIT 50 prevents over-fetching
  </action>
  <verify>
1. Run `npx tsc --noEmit` to verify TypeScript compiles
2. Test via Node REPL or a quick test script:
   ```typescript
   import { search } from './src/lib/search-actions';
   // Mock session or run with authenticated context
   const result = await search('test');
   console.log(result);
   ```
3. Verify performance in database:
   ```sql
   EXPLAIN ANALYZE
   SELECT id, ts_rank("searchVector", websearch_to_tsquery('english', 'test'))
   FROM "Post"
   WHERE "searchVector" @@ websearch_to_tsquery('english', 'test');
   ```
   Should show "Index Scan using Post_searchVector_idx" (not Seq Scan).
  </verify>
  <done>
search-actions.ts exports search function that returns ranked results from Post, User, and Course with snippets. Duration tracking confirms sub-100ms performance.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit` passes
2. New post creates with plainText: Create post via UI, verify in database
3. Existing posts backfilled: `SELECT COUNT(*) FROM "Post" WHERE "plainText" IS NULL` returns 0
4. Search returns results: Call search('test') and get results array
5. Ranking works: Title matches (users, courses) rank higher than content matches (posts)
6. Performance: Search duration < 100ms (logged in response)
7. GIN index used: EXPLAIN ANALYZE shows Index Scan, not Seq Scan
</verification>

<success_criteria>
- post-actions.ts populates plainText on create/update
- All existing posts have plainText populated (backfill complete)
- search-actions.ts exports search function
- Search returns ranked results from Post, User, Course
- Title matches rank higher than content-only matches
- Search results include snippet with matched text highlighted
- Search completes in under 100ms (as measured by duration field)
</success_criteria>

<output>
After completion, create `.planning/phases/12-search-infrastructure/12-02-SUMMARY.md`
</output>
